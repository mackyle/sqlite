/*
** 2022 March 20
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code to implement the "tclshext" shell extension
** for use with the extensible "sqlite3" CLI shell. On *Nix, build thusly:
     tool/mkshellc.tcl ext/misc/tclshext.c.in > tclshext.c
     gcc -shared -fPIC -O2 -I. -Isrc -I/usr/include/tcl8.6 tclshext.c \
       -o tclshext.so -ltcl8.6
** Later TCL versions can be used if desired.
**
** This extension adds two features to the host shell:
** 1. The .tcl dot command is added.
** 2. TCL scripting support is added.
**
** The .tcl command can be run with 0 or more arguments.
** With no arguments, it does a REPL loop until the end of input is seen.
** The end of input is either an EOF condition or a lone '.' on a line.
** With more arguments, files they name are interpreted as TCL script.
** In either case, the TCL command return code is tranlated to a DotCmdRC.
**
** TCL scripting support is added with a ShellExtensionAPI hookScripting()
** call in the manner documented for it and the ScriptHooks struct. This
** support lasts until the extension destructor is called. Until then,
** shell input groups beginning with ".." are treated as TCL input, one
** complete TCL command at a time.
**
** For any of these ways of providing TCL input, the same TCL interpreter
** is used, with its state maintained from one input to the next. In this
** way, .sqliterc or other preparatory shell scripts (or typing) can be
** made to provide a useful set of user-defined shell enhancements.
*/

#include <limits.h>
#include "shext_linkage.h"

static struct ShExtAPI *pShExtApi = 0;
static struct ExtHelpers *pExtHelpers = 0;

SQLITE_EXTENSION_INIT1;

/* This is not found in the API pointer table published for extensions: */
#define sqlite3_enable_load_extension pExtHelpers->enable_load_extension

/* Control how tclsqlite.c compiles. (REPL is effected here, not there.) */
#undef SQLITE_AMALGAMATION
#undef TCLSH
#include <tclOO.h>
INCLUDE tclsqlite.c

#if defined(_WIN32) || defined(WIN32)
# define getDir(cArray) _getwd(cArray)
# define chdir(s) _chdir(s)
#else
# define getDir(cArray) getcwd(cArray, sizeof(cArray))
#endif

typedef struct TclCmd TclCmd;

static void TclCmd_Takedown(TclCmd *ptc);

/* These DERIVED_METHOD(...) macro calls' arguments were copied and
 * pasted from the MetaCommand interface declaration in shext_linkage.h
 */
DERIVED_METHOD(void, destruct, MetaCommand,TclCmd, 0, ()){
  TclCmd_Takedown((TclCmd *)pThis);
}

DERIVED_METHOD(const char *, name, MetaCommand,TclCmd, 0,()){
  return "tcl";
}

DERIVED_METHOD(const char *, help, MetaCommand,TclCmd, 1,(int more)){
  switch( more ){
  case 0: return
      ".tcl ?FILES?   Run a TCL REPL or interpret files as TCL\n";
  case 1: return
      "   If FILES are provided, they name files to be read in as TCL.\n"
      "   Otherwise, a read/evaluate/print loop is run until a lone \".\"\n"
      "   is entered on an input line or end-of-stream is encountered.\n";
  default: return 0;
  }
}

DERIVED_METHOD(DotCmdRC, argsCheck, MetaCommand,TclCmd, 3,
             (char **pzErrMsg, int nArgs, char *azArgs[])){
  return DCR_Ok;
}

static Tcl_Interp *getInterp(TclCmd *ptc);

static void copy_complaint(char **pzErr, Tcl_Interp *pi){
  if( pzErr ){
    Tcl_Obj *po = Tcl_GetObjResult(pi);
    *pzErr = sqlite3_mprintf("%s\n", Tcl_GetStringFromObj(po,0));
  }
}

DERIVED_METHOD(DotCmdRC, execute, MetaCommand,TclCmd, 4,
             (ShellExState *psx, char **pzErrMsg, int nArgs, char *azArgs[])){
  FILE *out = pExtHelpers->currentOutputFile(psx);
  TclCmd *ptc = (TclCmd *)pThis;
  DotCmdRC rv = DCR_Ok;
  int rc = TCL_OK;
  if( nArgs>1 ){
    /* Read named files into the interpreter. */
    int aix;
    for( aix=0; aix<(nArgs-1) && rc==TCL_OK; ++aix ){
      rc = Tcl_EvalFile(getInterp(ptc), azArgs[aix+1]);
    }
  }else{
    /* Enter a REPL */
    static const char * const zREPL =
#ifdef TCL_REPL_STDIN_ONLY /* a fallback for debug */
      "set line {}\n"
      "while {![eof stdin]} {\n"
        "if {$line!=\"\"} {\n"
          "puts -nonewline \"> \"\n"
        "} else {\n"
          "puts -nonewline \"% \"\n"
        "}\n"
        "flush stdout\n"
        "append line [gets stdin]\n"
        "if {$line eq \".\"} break\n"
        "if {[info complete $line]} {\n"
          "if {[catch {uplevel #0 $line} result]} {\n"
            "puts stderr \"Error: $result\"\n"
          "} elseif {$result!=\"\"} {\n"
            "puts $result\n"
          "}\n"
          "set line {}\n"
        "} else {\n"
          "append line \\n\n"
        "}\n"
      "}\n"
      "if {$line ne \".\"} {puts {}}\n"
      "read stdin 0\n"
#else
      "namespace eval ::REPL {\n"
        "variable line {}\n"
        "variable at_end 0\n"
        "variable prompting [now_interactive]\n"
      "}\n"
      "while {!$::REPL::at_end} {\n"
        "if {$::REPL::prompting} {\n"
          "if {$::REPL::line!=\"\"} {\n"
            "puts -nonewline \"...> \"\n"
          "} else {\n"
            "puts -nonewline \"tcl% \"\n"
          "}\n"
        "}\n"
        "flush stdout\n"
        "set ::REPL::li [get_input_line]\n"
        "if {$::REPL::li eq \"\"} {\n"
          "set ::REPL::at_end 1\n"
        "} elseif {[string trimright $::REPL::li] eq \".\"} {\n"
          "if {$::REPL::line ne \"\"} {\n"
            "throw {NONE} {incomplete input at EOF}\n"
          "}\n"
          "set ::REPL::at_end 1\n"
        "} else {\n" 
          "append ::REPL::line $::REPL::li\n"
          "if {[string trim $::REPL::line] eq \"\"} {\n"
            "set ::REPL::line \"\"\n"
            "continue\n"
          "}\n" 
          "if {[info complete $::REPL::line]} {\n"
            "set ::REPL::rc [catch {uplevel #0 $::REPL::line} ::REPL::result]\n"
            "if {$::REPL::rc == 0} {\n"
              "if {$::REPL::result!=\"\" && $::REPL::prompting} {\n"
                "puts $::REPL::result\n"
              "}\n"
            "} elseif {$::REPL::rc == 1} {\n"
              "puts stderr \"Error: $::REPL::result\"\n"
            "} elseif {$::REPL::rc == 2} {\n"
              "set ::REPL::at_end 1\n"
            "}\n"
            "set ::REPL::line {}\n"
          "}\n"
        "}\n"
      "}\n"
      "if {$::REPL::prompting && $::REPL::li ne \".\\n\"} {puts {}}\n"
      "namespace delete ::REPL\n"
      "read stdin 0\n"
#endif
      ; //... ToDo: Get line editing working here. Reuse shell's line entry.
    rc = Tcl_Eval(getInterp(ptc), zREPL);
    clearerr(stdin); /* Cure issue where stdin gets stuck after keyboard EOF. */
  }
  if( rc!=TCL_OK ){
    copy_complaint(pzErrMsg, getInterp(ptc));
    rv = DCR_Error;
  }
  return rv;
}

/* Define a MetaCommand v-table initialized to reference above methods. */
MetaCommand_IMPLEMENT_VTABLE(TclCmd, tclcmd_methods);

INSTANCE_BEGIN(TclCmd);
  Tcl_Interp *interp;
INSTANCE_END(TclCmd) tclcmd = {
  &tclcmd_methods
  , 0 /* interp pointer */
};

static Tcl_Interp *getInterp(TclCmd *ptc){
  return ptc->interp;
}

static void TclCmd_Takedown(TclCmd *ptc){
  Tcl_DeleteInterp(ptc->interp);
  ptc->interp = 0;
  Tcl_Finalize();
}

/* Say line is script lead-in iff its first dark is "..". */
static int tclIsScriptLead(void *pvState, const char *zLineLead){
  char c;
  (void)(pvState);
  while( (c=*zLineLead++) && (c==' '||c=='\t') ) {}
  return (c=='.' && *zLineLead=='.');
}

static int tclIsComplete(void *pvState, const char *zScript){
  (void)(pvState);
  return Tcl_CommandComplete(zScript);
}

static DotCmdRC tclRunScript(void *pvState, const char *zScript,
                             ShellExState *p, char **pzErrMsg){
  char c;
  TclCmd *ptc = (TclCmd *)pvState;
  while( (c=*zScript++) && (c==' '||c=='\t') ) {}
  if( c=='.' &&  *zScript++=='.' ){
    int rc, nc = strlen30(zScript);
    rc = Tcl_EvalEx(ptc->interp, zScript, nc, TCL_EVAL_DIRECT|TCL_EVAL_GLOBAL);
    if( rc!=TCL_OK ) copy_complaint(pzErrMsg, getInterp(ptc));
    return DCR_Ok|(rc!=TCL_OK);
  }
  return DCR_Error;
}

#define GETLINE_MAXLEN 1000

/* C implementation of TCL proc, get_input_line */
static int getInputLine(void *pvSS, Tcl_Interp *interp,
                        int nArgs, const char *azArgs[]){
  if( nArgs==1 ){
    char buffer[GETLINE_MAXLEN+1];
    ShellExState *psx = (ShellExState *)pvSS;
    struct InSource *pis = pExtHelpers->currentInputSource(psx);
    if( pExtHelpers->strLineGet(buffer, GETLINE_MAXLEN, pis) ){
      Tcl_SetResult(interp, buffer, TCL_VOLATILE);
    }else{
      Tcl_SetResult(interp, 0, 0);
    }
    return TCL_OK;
  }else{
    Tcl_SetResult(interp, "too many arguments", TCL_STATIC);
    return TCL_ERROR;
  }
}

/* C implementation of TCL proc, now_interactive */
static int nowInteractive(void *pvSS, Tcl_Interp *interp,
                          int nArgs, const char *azArgs[]){
  if( nArgs==1 ){
    ShellExState *psx = (ShellExState *)pvSS;
    struct InSource *pis = pExtHelpers->currentInputSource(psx);
    static const char * zAns[2] = { "0","1" };
    int iiix = (pExtHelpers->nowInteractive(psx) != 0);
    Tcl_SetResult(interp, (char *)zAns[iiix], TCL_STATIC);
    return TCL_OK;
  }else{
    Tcl_SetResult(interp, "too many arguments", TCL_STATIC);
    return TCL_ERROR;
  }
}

#define UNKNOWN_RENAME "::_original_unknown"

/* C implementation of TCL ::unknown to (maybe) delegate to dot commands */
static int unknownDotDelegate(void *pvSS, Tcl_Interp *interp,
                                int nArgs, const char *azArgs[]){
  const char *name = (nArgs>1 && *azArgs[1]=='.')? azArgs[1]+1 : 0;
  ShellExState *psx = (ShellExState *)pvSS;
  MetaCommand *pmc = 0;
  int nFound = 0;
  int ia, rc;

  if( name ) pmc = pExtHelpers->findMetaCommand(name, psx, &nFound);
  if( pmc==(MetaCommand*)&tclcmd && nArgs==2 ){
    /* Will not do a nested REPL, just silently semi-fake it. */
    return TCL_OK;
  }
  if( pmc && nFound==1 ){
    /* Run the dot command and interpret its returns. */
    DotCmdRC drc = pExtHelpers->runMetaCommand(pmc, (char **)azArgs+1,
                                               nArgs-1, psx);
    if( drc==DCR_Ok ) return TCL_OK;
    else if( drc==DCR_Return ){
      return TCL_RETURN;
    }else{
      Tcl_AppendResult(interp, "Execution of .", name, " failed.", 0);
      return TCL_ERROR;
    }
  }else{
    /* Defer to the TCL-default ::unknown command, or fail here. */
    int haveUnkCmd = (0!=Tcl_FindCommand(interp, UNKNOWN_RENAME,
                                         0, TCL_GLOBAL_ONLY));
    if( haveUnkCmd ){
      Tcl_Obj **ppo = sqlite3_malloc((nArgs+1)*sizeof(Tcl_Obj*));
      if( ppo==0 ) return TCL_ERROR;
      ppo[0] = Tcl_NewStringObj(UNKNOWN_RENAME, -1);
      Tcl_IncrRefCount(ppo[0]);
      for( ia=1; ia<nArgs; ++ia ){
        ppo[ia] = Tcl_NewStringObj(azArgs[ia], -1);
        Tcl_IncrRefCount(ppo[ia]);
      }
      rc = Tcl_EvalObjv(interp, nArgs, ppo, TCL_EVAL_GLOBAL);
      for( ia=0; ia<nArgs; ++ia ) Tcl_DecrRefCount(ppo[ia]);
      return TCL_OK;
    }else{
      /* Fail now (instead of recursing back into this handler.) */
      Tcl_AppendResult(interp,
                       "Command ", azArgs[1], " does not exist.", (char *)0);
      return TCL_ERROR;
    }
  }
}

/* Forward reference for use as ExtensionId */
int sqlite3_tclshext_init(sqlite3*, char**, const sqlite3_api_routines*);

/* TCL dbu command: Acts like a (TCL) sqlite3 command created object except
 * that it defers to shell's DB and treats the close subcommand as an error.
 * The below struct and functions through userDbInit() support this feature.
 */
typedef struct UserDb {
  SqliteDb **ppSdb;   /* Some tclsqlite.c "sqlite3" DB objects, held here. */
  int numSdb;         /* How many "sqlite3" objects are now being held */
  int ixSdb;          /* Which held "sqlite3" object is the .userDb, if any */
  int nRef;           /* TCL object sharing counter */
  Tcl_Interp *interp; /* For creation of newly visible .dbUser DBs */
  ShellExState *psx;  /* For shell state access when .eval is run */
} UserDb;

/* Add a DB to the list. Return its index. */
static int udbAdd(UserDb *pudb, sqlite3 *udb){
  SqliteDb *p;
  int nshift;
  pudb->ppSdb
    = (SqliteDb**)Tcl_Realloc((char*)pudb->ppSdb, (pudb->numSdb+1)*sizeof(p));
  memset(pudb->ppSdb + pudb->numSdb, 0, sizeof(SqliteDb*));
  p = (SqliteDb*)Tcl_Alloc(sizeof(SqliteDb));
  memset(p, 0, sizeof(SqliteDb));
  pudb->ppSdb[pudb->numSdb] = p;
  p->db = udb;
  p->interp = pudb->interp;
  p->maxStmt = NUM_PREPARED_STMTS;
  p->openFlags = SQLITE_OPEN_URI;
  p->nRef = 1;
  return pudb->numSdb++;
}

/* Remove a DB from the list */
static void udbRemove(UserDb *pudb, int ix){
  SqliteDb *pdb;
  assert(ix>=0 && ix<pudb->numSdb);
  /* The code below is highly dependent upon implementation details of
   * tclsqlite.c , and may become incorrect if that code changes. This
   * is an accepted downside of reusing vast portions of that code.
   * The minutiae in these comments is to explain the dependencies so
   * that adjustments might be easily made when proven necessary. */
  pdb = pudb->ppSdb[ix];
#ifndef SQLITE_OMIT_INCRBLOB
  /* This is a preemptive action, which is normally done by the
   * delDatabaseRef() routine, which needs a non-zero db pointer
   * to reach Tcl_UnregisterChannel()'s implementation. We do it
   * now because, to avoid closing that db, that pointer will be
   * set to 0 when delDatabaseRef() runs. */
  closeIncrblobChannels(pdb);
  /* Prevent closeIncrblobChannels() from trying to free anything. */
  pdb->pIncrblob = 0;
#endif
  /* This appears to not be necessary, but is defensive in case the
   * flushStmtCache() or dbFreeStmt() code begins to use pdb->db .
   * We rely on its behavior whereby, once flushed, the cache is
   * made to appear empty in the SqliteDb struct. */
  flushStmtCache(pdb);
  /* This next intervention prevents delDatabaseRef() from closing
   * the .db ; this relies on sqlite3_close(0) being a NOP. If the
   * SqliteDb takedown code changes, this may lead to an address
   * fault. For that reason, the *.in which produces this source
   * should be tested by excercising the TCL udb command. */
  pdb->db = 0;
  assert(pdb->nRef==1);
  /* Use the "stock" delete for sqlite3-generated objects. */
  delDatabaseRef(pdb);
  /* At this point, pdb has been Tcl_Free()'ed. Forget it. */
  --pudb->numSdb;
  {
    int nshift = pudb->numSdb-ix;
    if( nshift>0 ){
      memmove(pudb->ppSdb+ix, pudb->ppSdb+ix+1, nshift*sizeof(pdb));
    }
  }
  /* Adjust index to currently visible DB. */
  if( ix==pudb->ixSdb ) pudb->ixSdb = -1;
  else if( ix<pudb->ixSdb ) --pudb->ixSdb;
}

static struct UserDb *udbCreate(Tcl_Interp *interp, ShellExState *psx);

/* Cleanup the UserDb singleton. Should only be done at shutdown. 
 * This routine is idempotent, and may be called redundantly.
 */
static void udbCleanup(UserDb *pudb){
  /* If this is called too early, when *pudb is still associated with
   * active (not yet closed) SqliteDb objects, those will simply be
   * orphaned and leaked. But this assert may make the error evident. */
  if( pudb==0 ) pudb = udbCreate(0, 0);
  assert(pudb->numSdb==0);
  pudb->numSdb==0;
  if( pudb->ppSdb ) Tcl_Free((char*)pudb->ppSdb);
  memset(pudb, 0, sizeof(UserDb));
  pudb->ixSdb = -1;
}

/* Hunt for given db in UserDb's list. Return its index if found, else -1. */
static int udbIndexOfDb(UserDb *pudb, sqlite3 *psdb){
  int ix = 0;
  while( ix < pudb->numSdb ){
    if( psdb==pudb->ppSdb[ix]->db ) return ix;
    else ++ix;
  }
  return -1;
}

/* The event handler used to keep udb command's wrapped DB in sync with
 * changes to the ShellExState .dbUser member. This task is complicated
 * by effects of these dot commands: .open ; .connection ; and .quit,
 * .exit or various other shell exit causes. The intention is to always
 * have an orderly and leak-free shutdown (excepting kill/OOM aborts.)
 */
static int udbEventHandle(void *pv, NoticeKind nk, void *pvSubject,
                          ShellExState *psx){
  UserDb *pudb = (UserDb*)pv;
  if( nk==NK_ShutdownImminent ){
    udbCleanup(pudb);
  }else if( nk==NK_Unsubscribe ){
    assert(pudb==0 || (pudb->nRef==0 && pudb->ppSdb==0));
  }else if( nk==NK_DbUserAppeared || nk==NK_DbUserVanishing
            || nk==NK_DbAboutToClose ){
    sqlite3 *dbSubject = (sqlite3*)pvSubject;
    int ix = udbIndexOfDb(pudb, dbSubject);
    switch( nk ){
    case NK_DbUserAppeared:
      if( ix>=0 ) pudb->ixSdb = ix;
      else pudb->ixSdb = udbAdd(pudb, dbSubject);
      break;
    case NK_DbUserVanishing:
      if( ix>=0 ) pudb->ixSdb = -1;
      break;
    case NK_DbAboutToClose:
      if( ix>=0 ) udbRemove(pudb, ix);
      break;
    }
  }
  return 0;
}

/* Create the UserDb object supporting TCL "udb" command operations. 
 * It's not wholly created because it is a singleton. Any subsequent
 * creation is ignored; instead, the singleton is returned. This
 * object is made to release resources only upon shutdown. If a TCL
 * user removes the udb command, this avoids problems arising from
 * this object holding references to databases that may still be in
 * use, either as the active .dbUser or as a blob streaming store. */
static struct UserDb *udbCreate(Tcl_Interp *interp, ShellExState *psx){
  static UserDb *rv = 0;
  static UserDb udb = { 0 };
  if( interp==0 || psx==0 ) return &udb;
  if( rv==0 ){
    sqlite3 *sdb = psx->dbUser;
    rv = &udb;
    rv->interp = interp;
    rv->psx = psx;
    rv->ppSdb = (SqliteDb**)Tcl_Alloc(5*sizeof(SqliteDb*));
    memset(rv->ppSdb, 0, 5*sizeof(SqliteDb*));
    if( sdb!=0 ){
      udbAdd(rv, sdb);
      rv->ixSdb = 0;
    } else rv->ixSdb = -1;
    rv->nRef = 1;
    /* Arrange that this object tracks lifetimes and visibility of the
     * ShellExState .dbUser member values which udb purports to wrap.
     * This subscription eventually leads to a udbCleanup() call. */
    pShExtApi->subscribeEvents(psx, sqlite3_tclshext_init,
                               rv, NK_CountOf, udbEventHandle);
  }
  return rv;
}

/* C implementation behind added TCL udb command */
static int UserDbObjCmd(void *cd, Tcl_Interp *interp,
                        int objc, Tcl_Obj * const * objv){
  UserDb *pudb = (UserDb*)cd;
  static const char *azDoHere[] = { "close", ".eval", 0 };
  enum DbDoWhat { DDW_Close, DDW_ShellEval } doWhat;

  /* Delegate all subcommands except above to the now-visible SqliteDb. */
  if( objc>=2 && !Tcl_GetIndexFromObj(interp, objv[1], azDoHere,
                                      "subcommand", 0, (int*)&doWhat)){
    switch( doWhat ){
    case DDW_Close:
      Tcl_AppendResult(interp, "Directly closing udb is disallowed.\n", 0);
      return TCL_ERROR;
    case DDW_ShellEval:
      Tcl_AppendResult(interp, "Faking .eval ...\n", 0);
      //... ToDo: Implement this.
      return TCL_OK;
    }
  }
  if( pudb->numSdb==0 || pudb->ixSdb<0 ){
    Tcl_AppendResult(interp, Tcl_GetStringFromObj(objv[0], (int*)0),
                     " references no DB yet.\n", 0);
    return TCL_ERROR;
  }
  return DbObjCmd(pudb->ppSdb[pudb->ixSdb], interp, objc, objv);
}

/* Get the udb command subsystem initialized and create "udb" TCL command. */
static int userDbInit(Tcl_Interp *interp, ShellExState *psx){
  UserDb *pudb = udbCreate(interp, psx);
  if( Tcl_CreateObjCommand(interp, "udb", (Tcl_ObjCmdProc*)UserDbObjCmd,
                           (char *)pudb, 0) ){
    ++pudb->nRef;
    return TCL_OK;
  }
  return TCL_ERROR;
}

/* Extension boiler-plate to grab ShellExtensionLink pointer from db. */
DEFINE_SHDB_TO_SHEXTLINK(shext_link);

/*
** Extension load function.
*/
#ifdef _WIN32
__declspec(dllexport)
#endif
int sqlite3_tclshext_init(
  sqlite3 *db,
  char **pzErrMsg,
  const sqlite3_api_routines *pApi
){
  ShellExtensionLink *pShExtLink;
  SQLITE_EXTENSION_INIT2(pApi);
  pShExtLink = shext_link(db);
  if( pShExtLink && pShExtLink->pShellExtensionAPI->numRegistrars>=1 ){
    ShellExState *psx = pShExtLink->pSXS;
    MetaCommand *pmc = (MetaCommand *)&tclcmd;
    const char *zShellName, *zShellDir;
    int rc;

    pShExtApi = & pShExtLink->pShellExtensionAPI->api.named;
    pExtHelpers = & pShExtLink->pShellExtensionAPI->pExtHelpers->helpers.named;
    if( pShExtLink->pShellExtensionAPI->pExtHelpers->helperCount < 10 ){
      *pzErrMsg = sqlite3_mprintf("Shell version mismatch");
      return SQLITE_ERROR;
    }
    zShellName = pExtHelpers->shellInvokedAs();
    zShellDir = pExtHelpers->shellStartupDir();
    if( zShellDir!=0 ){
      char cwd[FILENAME_MAX+1];
      if( getDir(cwd) && 0==chdir(zShellDir) ){
        Tcl_FindExecutable(zShellName);
        rc = chdir(cwd); /* result ignored, kept only to silence gcc */
      }
    }
    tclcmd.interp = Tcl_CreateInterp();
    Tcl_SetSystemEncoding(tclcmd.interp, "utf-8");
    Sqlite3_Init(tclcmd.interp);
    if( 0==Tcl_OOInitStubs(tclcmd.interp) ){
      *pzErrMsg = sqlite3_mprintf("Tcl v8.6 or higher required.\n");
      TclCmd_Takedown(&tclcmd);
      return SQLITE_ERROR;
    }
    rc = pShExtApi->registerMetaCommand(psx, sqlite3_tclshext_init, pmc);
    if( rc==SQLITE_OK ){
      ScriptHooks sh = { pmc, tclIsScriptLead, tclIsComplete, tclRunScript };
      int irc = Tcl_Init(tclcmd.interp);
      if( irc==TCL_OK ){
        if( TCL_OK==userDbInit(tclcmd.interp, psx) ){
          UserDb *pudb = udbCreate(tclcmd.interp, psx);
          pShExtLink->extensionDestruct = (void (*)(void*))udbCleanup;
          pShExtLink->pvExtensionObject = pudb;
        }
        pShExtApi->hookScripting(psx, sqlite3_tclshext_init, &sh);
        Tcl_CreateCommand(tclcmd.interp,
                          "get_input_line", getInputLine, psx, 0);
        Tcl_CreateCommand(tclcmd.interp,
                          "now_interactive", nowInteractive, psx, 0);
        Tcl_Eval(tclcmd.interp, "rename unknown "UNKNOWN_RENAME);
        Tcl_CreateCommand(tclcmd.interp,
                          "unknown", unknownDotDelegate, psx, 0);
        pShExtLink->eid = sqlite3_tclshext_init;
      }else{
        TclCmd_Takedown(&tclcmd);
        rc = SQLITE_ERROR;
      }
    }else{
      TclCmd_Takedown(&tclcmd);
    }
    return rc;
  }
  else{
    *pzErrMsg
      = sqlite3_mprintf("Bad ShellExtensionLink or registration API.\n");
    return SQLITE_ERROR;
  }
}
