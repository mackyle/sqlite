# 2020 Jan 20
#
# The author disclaims copyright to this source code.  In place of
# a legal notice, here is a blessing:
#
#    May you do good and not evil.
#    May you find forgiveness for yourself and forgive others.
#    May you share freely, never taking more than you give.
#
#***********************************************************************
#

set testdir [file dirname $argv0]
source $testdir/tester.tcl
source $testdir/lock_common.tcl
set ::testprefix concreport

ifcapable !concurrent {
  finish_test
  return
}

proc do_concreport_test {tn sql res report} {
  uplevel [list do_execsql_test $tn.1 "
    BEGIN CONCURRENT;
      $sql ;
    COMMIT;
  " $res]

  uplevel [list do_test $tn.2 {
    list {*}[sqlite3_begin_concurrent_report db]
  } [list {*}$report]]
}

do_execsql_test 1.0 {
  PRAGMA journal_mode = wal;
} {wal}

do_execsql_test 1.1 {
  CREATE TABLE t1(k INTEGER PRIMARY KEY, v);
  WITH s(i) AS (
    SELECT 1 UNION ALL SELECT i+1 FROM s WHERE i<100
  )
  INSERT INTO t1 SELECT i, i FROM s;

  BEGIN CONCURRENT;
    SELECT * FROM t1 WHERE k = 5;
    SELECT * FROM t1 WHERE k = 10;
  COMMIT;
} {5 5 10 10}
do_test 1.1.1 {
  list {*}[sqlite3_begin_concurrent_report db]
} [list {2:[10..10]} {2:[5..5]}]

do_concreport_test 1.2 {
  SELECT * FROM t1 WHERE k = 100;
} {100 100} {
  2:[100..100]
}

do_concreport_test 1.3 {
  SELECT * FROM t1 WHERE k >= 10 AND k <= 13;
} {10 10 11 11 12 12 13 13} {
  2:[10..13]
}

do_concreport_test 1.4 {
  SELECT max(k) FROM t1;
} {100} {
  2:[100..EOF)
}
do_concreport_test 1.5 {
  SELECT min(k) FROM t1;
} {1} {
  2:(EOF..1]
}

do_concreport_test 1.6 {
  SELECT * FROM t1 WHERE k IN (4, 6, 8)
} {4 4 6 6 8 8} {
  2:[8..8]
  2:[6..6]
  2:[4..4]
}

do_concreport_test 1.7 {
  SELECT v FROM t1 WHERE k > 22 LIMIT 5
} {23 24 25 26 27} {
  2:(22..27]
}

do_concreport_test 1.8 {
  SELECT v FROM t1 WHERE k > 22 ORDER BY k DESC LIMIT 5
} {100 99 98 97 96} {
  2:[96..EOF)
}

do_concreport_test 1.9 {
  SELECT v FROM t1 WHERE k > 21 AND k < 25
} {22 23 24} {
  2:(21..25)
}
do_concreport_test 1.10 {
  SELECT v FROM t1 WHERE k > 21 AND k < 25 ORDER BY k DESC
} {24 23 22} {
  2:(21..25)
}

do_concreport_test 1.11 {
  SELECT v FROM t1 WHERE k > 98 AND k < 200
} {99 100} {
  2:(98..200)
}

do_concreport_test 1.12 {
  SELECT v FROM t1 WHERE k >= 98 AND k <= 200
} {98 99 100} {
  2:[98..200]
}

# This case does not work. The result should be [101..200], but as there
# are no rows matching (k>=101) the system never sees the (k<=200) 
# constraint. Hence "..EOF".
do_concreport_test 1.13 {
  SELECT v FROM t1 WHERE k >= 101 AND k <= 200
} {} {
  2:[101..EOF)
}

do_concreport_test 1.14 {
  SELECT v FROM t1 WHERE +v=5
} {5} {
  2:(EOF..EOF)
}

#--------------------------------------------------------------------------
reset_db
do_execsql_test 2.0 {
  PRAGMA journal_mode = wal;
  CREATE TABLE t2(k PRIMARY KEY, v);
  INSERT INTO t2 VALUES('a',  1);
  INSERT INTO t2 VALUES('b',  2);
  INSERT INTO t2 VALUES('c',  3);
  INSERT INTO t2 VALUES('d',  4);
  INSERT INTO t2 VALUES('e',  5);
  INSERT INTO t2 VALUES('f',  6);
  INSERT INTO t2 VALUES('g',  7);
  INSERT INTO t2 VALUES('h',  8);
  INSERT INTO t2 VALUES('i',  9);
  INSERT INTO t2 VALUES('j', 10);
  INSERT INTO t2 VALUES('k', 11);
}

explain_i {
  SELECT * FROM t2 WHERE k = 'e'
}
breakpoint
do_concreport_test 2.1 {
  SELECT * FROM t2 WHERE k = 'e'
} {e 5} {
  2:
}

finish_test

